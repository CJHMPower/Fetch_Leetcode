//-*- coding:utf-8 -*-
// Generated by the Fetch-Leetcode project on the Github
// https://github.com/CJHMPower/Fetch-Leetcode/

// 86 Partition List
// https://leetcode.com//problems/partition-list/description/
// Fetched at 2018-07-24
// Submitted 1 year, 10 months ago
// Runtime: 6 ms
// This solution defeats 3.96% cpp solutions

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
 public:
  ListNode* del(ListNode* p) {
    if (p == nullptr || p->next == nullptr) {
      return nullptr;
    }
    ListNode* r = p->next;
    ListNode* temp = r->next;
    p->next = temp;
    r->next = nullptr;
    return r;
  }
  ListNode* partition(ListNode* head, int x) {
    if (head == nullptr || head->next == nullptr) {
      return head;
    }
    ListNode* tails = (ListNode*)malloc(sizeof(ListNode));
    tails->next = nullptr;
    ListNode* nhead = tails;
    ListNode* p = head;
    while (p != nullptr && p->val < x) {
      p = p->next;
    }
    if (p == nullptr) {
      return head;
    }
    ListNode* q = head;
    if (q != p) {
      while (q->next != p) {
        q = q->next;
      }
      q->next = nullptr;
      tails->next = head;
      tails = q;
      q->next = nullptr;
    }
    head = p;
    ListNode* prep = p;
    p = p->next;
    while (p) {
      if (p->val < x) {
        ListNode* temp = del(prep);
        tails->next = temp;
        tails = tails->next;
        tails->next = nullptr;
        if (prep->next != nullptr)
          p = prep->next;
        else {
          break;
        }
      } else {
        prep = prep->next;
        p = prep->next;
      }
    }
    tails->next = head;
    ListNode* tp = nhead;
    nhead = nhead->next;
    free(tp);
    return nhead;
  }
};