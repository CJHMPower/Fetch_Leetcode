//-*- coding:utf-8 -*-
// Generated by the Fetch-Leetcode project on the Github
// https://github.com/CJHMPower/Fetch-Leetcode/

// 235 Lowest Common Ancestor of a Binary Search Tree
// https://leetcode.com//problems/lowest-common-ancestor-of-a-binary-search-tree/description/
// Fetched at 2018-07-24
// Submitted 2 years, 1 month ago
// Runtime: 40 ms

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
 public:
  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (root == NULL || p == root || q == root) {
      return root;
    }
    vector<TreeNode*> pathp;
    vector<TreeNode*> pathq;
    TreeNode* s = root;
    pathp.push_back(s);
    while (true) {
      if (s == p) {
        pathp.push_back(s);
        break;
      } else if (s->val > p->val) {
        s = s->left;
        pathp.push_back(s);
      } else if (s->val < p->val) {
        s = s->right;
        pathp.push_back(s);
      }
    }
    s = root;
    pathq.push_back(s);
    while (true) {
      if (s == q) {
        pathq.push_back(s);
        break;
      } else if (s->val > q->val) {
        s = s->left;
        pathq.push_back(s);
      } else if (s->val < q->val) {
        s = s->right;
        pathq.push_back(s);
      }
    }
    int i = 0, j = 0;
    while (pathp[i] == pathq[j]) {
      if (i + 1 < pathp.size()) i++;
      if (j + 1 < pathq.size()) j++;
    }
    return pathp[max(i, j) - 1];
  }
};