//-*- coding:utf-8 -*-
// Generated by the Fetch-Leetcode project on the Github
// https://github.com/CJHMPower/Fetch-Leetcode/

// 235 Lowest Common Ancestor of a Binary Search Tree
// https://leetcode.com//problems/lowest-common-ancestor-of-a-binary-search-tree/description/
// Fetched at 2018-07-24
// Submitted 1 year, 10 months ago
// Runtime: 43 ms

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
 public:
  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (root == nullptr) {
      return nullptr;
    }
    vector<TreeNode*> ppath;
    vector<TreeNode*> qpath;
    TreeNode* r = root;
    while (r != p) {
      ppath.push_back(r);
      if (r->val > p->val) {
        r = r->left;
      } else {
        r = r->right;
      }
    }
    ppath.push_back(p);
    r = root;
    while (r != q) {
      qpath.push_back(r);
      if (r->val > q->val) {
        r = r->left;
      } else {
        r = r->right;
      }
    }
    qpath.push_back(q);
    int i = 0;
    while (i < ppath.size() && i < qpath.size() && ppath[i] == qpath[i]) {
      i++;
    }
    if (ppath.size() < qpath.size()) {
      return ppath[i - 1];
    } else {
      return qpath[i - 1];
    }
  }
};