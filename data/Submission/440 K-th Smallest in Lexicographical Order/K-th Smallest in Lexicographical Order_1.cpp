//-*- coding:utf-8 -*-
// Generated by the Fetch-Leetcode project on the Github
// https://github.com/CJHMPower/Fetch-Leetcode/

// 440 K-th Smallest in Lexicographical Order
// https://leetcode.com//problems/k-th-smallest-in-lexicographical-order/description/
// Fetched at 2018-07-24
// Submitted 5 months, 4 weeks ago
// Runtime: 4 ms

class Solution {
 public:
  int find_rank(int m, int val) {
    int ret = 0;
    string s = to_string(val);
    ret += stoi(string(m, '1')) * (int(s[0] - '0') - 1);
    for (int i = 1; i < s.size(); i++) {
      ret++;
      ret += stoi(string(m - i, '1')) * int(s[i] - '0');
    }
    return ret + 1;
  }
  int layer_rank(int m, int k) {
    vector<int> cmp;
    for (int i = m; i >= 1; i--) {
      cmp.push_back(stoi(string(i, '1')));
    }
    string s = "";
    int head = (k - 1) / cmp[0] + 1;
    k -= (head - 1) * cmp[0];
    s = s + to_string(head);
    int i = 1;
    while (k > 0) {
      k--;
      if (k <= 0) {
        break;
      }
      head = (k - 1) / cmp[i];
      k -= head * cmp[i];
      s = s + to_string(head);
      i++;
    }
    return stoi(s);
  }
  int findKthNumber(int n, int k) {
    if (k == 1) {
      return 1;
    }
    int m = 0;
    while (pow(10, m) <= n) {
      m++;
    }
    int n_index = find_rank(m, n);
    if (n_index == k) {
      return n;
    } else if (n_index > k) {
      return layer_rank(m, k);
    } else {
      int n_next = stoi(to_string(n).substr(0, m - 1)) + 1;
      int n_next_index = find_rank(m - 1, n_next);
      int target_index = n_next_index + (k - n_index) - 1;
      int ret = layer_rank(m - 1, target_index);
      return ret;
    }
  }
};