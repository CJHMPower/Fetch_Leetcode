//-*- coding:utf-8 -*-
// Generated by the Fetch-Leetcode project on the Github
// https://github.com/CJHMPower/Fetch-Leetcode/

// 688 Knight Probability in Chessboard
// https://leetcode.com//problems/knight-probability-in-chessboard/description/
// Fetched at 2018-07-24
// Submitted 5 months, 3 weeks ago
// Runtime: 8 ms
// This solution defeats 30.41% cpp solutions

class Solution {
 public:
  bool is_board(int N, int r, int c) {
    return r >= 0 && r < N && c >= 0 && c < N;
  }
  double knightProbability(int N, int K, int r, int c) {
    if (K == 0) {
      return 1.0;
    }
    vector<vector<vector<double>>> dp(
        K + 1, vector<vector<double>>(N, vector<double>(N, 1.0)));
    for (int k = 1; k <= K; k++) {
      for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
          double prob = 0;
          if (is_board(N, i + 2, j + 1)) {
            prob += 1.0 / 8 * dp[k - 1][i + 2][j + 1];
          }
          if (is_board(N, i + 2, j - 1)) {
            prob += 1.0 / 8 * dp[k - 1][i + 2][j - 1];
          }
          if (is_board(N, i - 2, j + 1)) {
            prob += 1.0 / 8 * dp[k - 1][i - 2][j + 1];
          }
          if (is_board(N, i - 2, j - 1)) {
            prob += 1.0 / 8 * dp[k - 1][i - 2][j - 1];
          }
          if (is_board(N, i + 1, j + 2)) {
            prob += 1.0 / 8 * dp[k - 1][i + 1][j + 2];
          }
          if (is_board(N, i + 1, j - 2)) {
            prob += 1.0 / 8 * dp[k - 1][i + 1][j - 2];
          }
          if (is_board(N, i - 1, j + 2)) {
            prob += 1.0 / 8 * dp[k - 1][i - 1][j + 2];
          }
          if (is_board(N, i - 1, j - 2)) {
            prob += 1.0 / 8 * dp[k - 1][i - 1][j - 2];
          }
          dp[k][i][j] = prob;
        }
      }
    }
    return dp[K][r][c];
  }
};