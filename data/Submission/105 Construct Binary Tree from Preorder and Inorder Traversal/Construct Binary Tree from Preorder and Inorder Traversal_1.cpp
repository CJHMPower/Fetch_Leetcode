//-*- coding:utf-8 -*-
// Generated by the Fetch-Leetcode project on the Github
// https://github.com/CJHMPower/Fetch-Leetcode/

// 105 Construct Binary Tree from Preorder and Inorder Traversal
// https://leetcode.com//problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/
// Fetched at 2018-07-24
// Submitted 2 years ago
// Runtime: 28 ms
// This solution defeats 19.23% cpp solutions

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
 public:
  void rebuild(int* preorder, int* inorder, int len, TreeNode** root) {
    if (preorder == nullptr) return;
    if (inorder == nullptr) return;
    TreeNode* temp = (TreeNode*)malloc(sizeof(TreeNode));
    temp->val = *preorder;
    temp->left = nullptr;
    temp->right = nullptr;
    if (*root == nullptr) *root = temp;
    if (len == 1) return;
    int* p = inorder;
    while (*p != *preorder) {
      p++;
    }
    int left_len = int(p - inorder);
    int right_len = len - left_len - 1;
    if (left_len > 0) {
      rebuild(preorder + 1, inorder, left_len, &((*root)->left));
    }
    if (right_len > 0) {
      rebuild(preorder + left_len + 1, inorder + left_len + 1, right_len,
              &((*root)->right));
    }
  }

  TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    if (preorder.empty() || inorder.empty()) {
      return nullptr;
    }
    TreeNode* root = nullptr;
    int* pre = new int[preorder.size()];
    int* inord = new int[inorder.size()];
    for (int i = 0; i < preorder.size(); i++) {
      pre[i] = preorder[i];
      inord[i] = inorder[i];
    }
    rebuild(pre, inord, preorder.size(), &root);
    return root;
  }
};