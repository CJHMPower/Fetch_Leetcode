//-*- coding:utf-8 -*-
// Generated by the Fetch-Leetcode project on the Github
// https://github.com/CJHMPower/Fetch-Leetcode/

// 91 Decode Ways
// https://leetcode.com//problems/decode-ways/description/
// Fetched at 2018-07-24
// Submitted 2 years ago
// Runtime: 4 ms
// This solution defeats 14.93% cpp solutions

class Solution {
 public:
  bool can_comb(char a, char b) {
    if (a >= '3' || a == '0') {
      return false;
    }
    if (a == '2') {
      return b <= '6';
    }
    return true;
  }
  bool can_alone(char a) { return a > '0' && a <= '9'; }
  int numDecodings(string s) {
    vector<int> dp(s.size());
    if (s.empty()) {
      return 0;
    }
    if (s[0] == '0') {
      return 0;
    }
    dp[0] = 1;
    if (can_alone(s[1]) && can_comb(s[0], s[1])) {
      dp[1] = 2;
    } else if (can_comb(s[0], s[1]) || can_alone(s[1])) {
      dp[1] = 1;
    } else
      dp[1] = 0;
    for (int i = 2; i < s.size(); i++) {
      bool cancomb = can_comb(s[i - 1], s[i]);
      bool canalone = can_alone(s[i]);
      if (cancomb && canalone) {
        dp[i] = dp[i - 1] + dp[i - 2];
      } else if (cancomb) {
        dp[i] = dp[i - 2];
      } else if (canalone) {
        dp[i] = dp[i - 1];
      } else {
        dp[i] = 0;
      }
    }
    return dp[s.size() - 1];
  }
};