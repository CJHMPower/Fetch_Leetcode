//-*- coding:utf-8 -*-
// Generated by the Fetch-Leetcode project on the Github
// https://github.com/CJHMPower/Fetch-Leetcode/

// 210 Course Schedule II
// https://leetcode.com//problems/course-schedule-ii/description/
// Fetched at 2018-07-24
// Submitted 1 year, 10 months ago
// Runtime: 26 ms
// This solution defeats 8.87% cpp solutions

class Solution {
 public:
  vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {
    vector<int> indegree(numCourses, 0);
    vector<int> paths;
    vector<vector<int>> graph(numCourses);
    for (auto it = prerequisites.begin(); it != prerequisites.end(); it++) {
      graph[it->first].push_back(it->second);
      indegree[it->second]++;
    }
    queue<int> q;
    int count = 0;
    vector<int> visited(numCourses, false);
    for (int i = 0; i < indegree.size(); i++) {
      if (indegree[i] == 0) {
        q.push(i);
        count++;
        visited[i] = true;
        paths.push_back(i);
      }
    }
    while (!q.empty()) {
      int v = q.front();
      q.pop();
      for (int i = 0; i < graph[v].size(); i++) {
        indegree[graph[v][i]]--;
        if (visited[graph[v][i]] == false && indegree[graph[v][i]] == 0) {
          count++;
          q.push(graph[v][i]);
          visited[graph[v][i]] = true;
          paths.push_back(graph[v][i]);
        }
      }
    }
    if (count == numCourses) {
      reverse(paths.begin(), paths.end());
      return paths;
    } else {
      return vector<int>();
    }
  }
};