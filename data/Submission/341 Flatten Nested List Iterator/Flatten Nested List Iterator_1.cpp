//-*- coding:utf-8 -*-
// Generated by the Fetch-Leetcode project on the Github
// https://github.com/CJHMPower/Fetch-Leetcode/

// 341 Flatten Nested List Iterator
// https://leetcode.com//problems/flatten-nested-list-iterator/description/
// Fetched at 2018-07-24
// Submitted 1 year, 10 months ago
// Runtime: 136 ms
// This solution defeats 1.1% cpp solutions

/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * class NestedInteger {
 *   public:
 *     // Return true if this NestedInteger holds a single integer, rather than
 * a nested list. bool isInteger() const;
 *
 *     // Return the single integer that this NestedInteger holds, if it holds a
 * single integer
 *     // The result is undefined if this NestedInteger holds a nested list
 *     int getInteger() const;
 *
 *     // Return the nested list that this NestedInteger holds, if it holds a
 * nested list
 *     // The result is undefined if this NestedInteger holds a single integer
 *     const vector<NestedInteger> &getList() const;
 * };
 */
class NestedIterator {
 public:
  bool helper(NestedInteger list) {
    if (list.isInteger()) {
      return true;
    }
    vector<NestedInteger> str = list.getList();
    for (auto it = str.begin(); it != str.end(); it++) {
      if (helper(*it)) {
        return true;
      }
    }
    return false;
  }
  NestedIterator(vector<NestedInteger> &nestedList) {
    if (nestedList.size()) {
      data = nestedList;
      int i = nestedList.size() - 1;
      while (i >= 0) {
        if (helper(nestedList[i])) {
          iter.push(nestedList[i]);
        }
        i--;
      }
    }
  }
  int next() {
    NestedInteger temp = iter.top();
    iter.pop();
    if (temp.isInteger()) {
      return temp.getInteger();
    } else {
      vector<NestedInteger> list = temp.getList();
      for (int i = list.size() - 1; i >= 0; i--) {
        if (helper(list[i])) {
          iter.push(list[i]);
        }
      }
    }
    return next();
  }

  bool hasNext() { return !iter.empty(); }
  vector<NestedInteger> data;
  stack<NestedInteger> iter;
};

/**
 * Your NestedIterator object will be instantiated and called as such:
 * NestedIterator i(nestedList);
 * while (i.hasNext()) cout << i.next();
 */