//-*- coding:utf-8 -*-
// Generated by the Fetch-Leetcode project on the Github
// https://github.com/CJHMPower/Fetch-Leetcode/

// 398 Random Pick Index
// https://leetcode.com//problems/random-pick-index/description/
// Fetched at 2018-07-24
// Submitted 1 year, 9 months ago
// Runtime: 239 ms

class Solution {
 public:
  Solution(vector<int> nums) {
    for (int i = 0; i < nums.size(); i++) {
      data.push_back({i, nums[i]});
    }
    auto cmp = [](pair<int, int> a, pair<int, int> b) {
      return a.second < b.second;
    };
    sort(data.begin(), data.end(), cmp);
  }
  int binary_search(vector<pair<int, int>>& nums, int target) {
    int low = 0, high = nums.size() - 1;
    int mid;
    while (low <= high) {
      mid = (high - low) / 2 + low;
      if (nums[mid].second == target) {
        do
          mid--;
        while (mid >= 0 && nums[mid].second == target);
        return nums[mid + 1].first;
      } else if (nums[mid].second > target) {
        high = mid - 1;
      } else {
        low = mid + 1;
      }
    }
    return -1;
  }
  int pick(int target) {
    int start = binary_search(data, target);
    int result = start;
    int i = 2;
    start++;
    uniform_real_distribution<double> u(0, 1);
    while (start < data.size() && data[start].second == target) {
      if (u(e) < 1.0 / i) {
        result = data[start].first;
      }
      i++;
      start++;
    }
    return result;
  }
  vector<pair<int, int>> data;
  default_random_engine e;
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(nums);
 * int param_1 = obj.pick(target);
 */