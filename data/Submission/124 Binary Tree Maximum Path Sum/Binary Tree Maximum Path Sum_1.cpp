//-*- coding:utf-8 -*-
// Generated by the Fetch-Leetcode project on the Github
// https://github.com/CJHMPower/Fetch-Leetcode/

// 124 Binary Tree Maximum Path Sum
// https://leetcode.com//problems/binary-tree-maximum-path-sum/description/
// Fetched at 2018-07-24
// Submitted 1 year, 10 months ago
// Runtime: 29 ms
// This solution defeats 6.39% cpp solutions

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
 public:
  int root_to_leaf(TreeNode* root) {
    if (root == nullptr) {
      return 0;
    }
    return max(0, max(root_to_leaf(root->left), root_to_leaf(root->right))) +
           root->val;
  }
  pair<int, int> helper(TreeNode* root) {
    if (root == nullptr) {
      return {0, 0};
    }
    pair<int, int> l = helper(root->left);
    pair<int, int> r = helper(root->right);
    int maxleft = l.first, maxright = r.first;
    int ret = max(max(root->val + maxleft + maxright, root->val),
                  max(root->val + maxleft, root->val + maxright));
    pair<int, int> result;
    result.first = max(0, max(l.first, r.first)) + root->val;
    if (root->left == nullptr) {
      if (root->right == nullptr) {
        result.second = ret;
      } else {
        result.second = max(ret, r.second);
      }
    } else if (root->right == nullptr) {
      result.second = max(l.second, ret);
    } else {
      result.second = max(max(l.second, r.second), ret);
    }
    return result;
  }
  int maxPathSum(TreeNode* root) { return helper(root).second; }
};