//-*- coding:utf-8 -*-
// Generated by the Fetch-Leetcode project on the Github
// https://github.com/CJHMPower/Fetch-Leetcode/

// 505 The Maze II
// https://leetcode.com//problems/the-maze-ii/description/
// Fetched at 2018-07-24
// Submitted 3 months, 1 week ago
// Runtime: 1531 ms
// This solution defeats 3.02% cpp solutions

class Solution {
 public:
  void DFS(vector<vector<int>>& maze, vector<vector<int>>& record,
           vector<int> start, vector<int>& dest, int val) {
    if (start[0] < 0 || start[1] < 0 || start[0] >= maze.size() ||
        start[1] >= maze[0].size() || maze[start[0]][start[1]] == 1 ||
        val >= record[start[0]][start[1]]) {
      return;
    }

    record[start[0]][start[1]] = val;

    int x = start[0], y = start[1], i = 0;
    while (x >= 0 && maze[x][y] != 1) {
      x--;
      i++;
    }
    DFS(maze, record, vector<int>{x + 1, y}, dest, val + i - 1);
    x = start[0], i = 0;
    while (x < maze.size() && maze[x][y] != 1) {
      x++;
      i++;
    }
    DFS(maze, record, vector<int>{x - 1, y}, dest, val + i - 1);
    x = start[0], y = start[1], i = 0;
    while (y >= 0 && maze[x][y] != 1) {
      y--;
      i++;
    }
    DFS(maze, record, vector<int>{x, y + 1}, dest, val + i - 1);
    y = start[1], i = 0;
    while (y < maze[0].size() && maze[x][y] != 1) {
      y++;
      i++;
    }
    DFS(maze, record, vector<int>{x, y - 1}, dest, val + i - 1);
  }
  int shortestDistance(vector<vector<int>>& maze, vector<int>& start,
                       vector<int>& destination) {
    vector<vector<int>> record(maze.size(),
                               vector<int>(maze[0].size(), INT_MAX));
    record[start[0]][start[1]] = 0;
    DFS(maze, record, start, destination, -1);
    if (record[destination[0]][destination[1]] == INT_MAX) {
      return -1;
    }
    return record[destination[0]][destination[1]] + 1;
  }
};