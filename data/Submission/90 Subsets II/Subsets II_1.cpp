//-*- coding:utf-8 -*-
// Generated by the Fetch-Leetcode project on the Github
// https://github.com/CJHMPower/Fetch-Leetcode/

// 90 Subsets II
// https://leetcode.com//problems/subsets-ii/description/
// Fetched at 2018-07-24
// Submitted 3 months ago
// Runtime: 11 ms
// This solution defeats 2.17% cpp solutions

class Solution {
 public:
  int backtrace(vector<vector<int>>& ret, int val, bool duplicated,
                int num = 0) {
    int n = ret.size();
    int count = 0;
    if (duplicated == false) {
      for (int i = 0; i < n; i++) {
        vector<int> temp = ret[i];
        temp.push_back(val);
        ret.push_back(temp);
        count++;
      }
    } else {
      for (int i = n - num; i < n; i++) {
        vector<int> temp = ret[i];
        temp.push_back(val);
        ret.push_back(temp);
        count++;
      }
    }
    return count;
  }

  vector<vector<int>> subsetsWithDup(vector<int>& nums) {
    sort(nums.begin(), nums.end());
    vector<vector<int>> ret;
    ret.push_back(vector<int>());
    if (nums.empty()) {
      return ret;
    }
    int count = backtrace(ret, nums[0], false);

    for (int i = 1; i < nums.size(); i++) {
      if (nums[i] != nums[i - 1]) {
        count = backtrace(ret, nums[i], false);
      } else {
        count = backtrace(ret, nums[i], true, count);
      }
    }
    return ret;
  }
};