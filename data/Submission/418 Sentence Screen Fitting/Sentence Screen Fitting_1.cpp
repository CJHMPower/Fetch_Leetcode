//-*- coding:utf-8 -*-
// Generated by the Fetch-Leetcode project on the Github
// https://github.com/CJHMPower/Fetch-Leetcode/

// 418 Sentence Screen Fitting
// https://leetcode.com//problems/sentence-screen-fitting/description/
// Fetched at 2018-07-24
// Submitted 2 months ago
// Runtime: 7 ms
// This solution defeats 59.94% cpp solutions

class Solution {
 public:
  vector<vector<int>> find_left(vector<string>& sentence, int cols) {
    int n = sentence.size();
    vector<vector<int>> dp(n, vector<int>(3, 0));

    int left = cols, j = 0, times = 0;
    bool flag = false;
    while (left >= sentence[j].size()) {
      left -= sentence[j].size();

      if (left > 0) {
        left--;
      } else {
        flag = true;
      }
      j++;
      if (j >= sentence.size()) {
        j = 0;
        times++;
      }
    }
    dp[0][0] = left;
    dp[0][1] = j;
    dp[0][2] = times;
    for (int i = 1; i < n; i++) {
      left = int(dp[i - 1][0] + sentence[i - 1].size()) + 1;
      if (dp[i - 1][0] == 0 && flag == true) {
        left--;
        flag = false;
      }

      times = dp[i - 1][2];

      j = dp[i - 1][1];

      while (left >= sentence[j].size()) {
        left -= sentence[j].size();

        if (left > 0) {
          left--;
        } else {
          flag = true;
        }
        j++;
        if (j >= n) {
          j = 0;
          times++;
        }
      }
      dp[i][0] = left;
      dp[i][1] = j;
      dp[i][2] = times;
    }
    return dp;
  }
  int wordsTyping(vector<string>& sentence, int rows, int cols) {
    vector<vector<int>> dp = find_left(sentence, cols);

    int ret = 0, start = 0, next = 0;
    for (int i = 0; i < rows; i++) {
      ret += dp[start][2];
      start = dp[start][1];
    }
    return ret;
  }
};