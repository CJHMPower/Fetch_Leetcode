//-*- coding:utf-8 -*-
// Generated by the Fetch-Leetcode project on the Github
// https://github.com/CJHMPower/Fetch-Leetcode/

// 222 Count Complete Tree Nodes
// https://leetcode.com//problems/count-complete-tree-nodes/description/
// Fetched at 2018-07-24
// Submitted 2 years, 1 month ago
// Runtime: 653 ms
// This solution defeats 4.11% cpp solutions

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
 public:
  int count_left_levels(TreeNode *root) {
    if (root == NULL) {
      return 0;
    }
    return count_left_levels(root->left) + 1;
  }
  int count_right_levels(TreeNode *root) {
    if (root == NULL) {
      return 0;
    }
    return count_right_levels(root->right) + 1;
  }
  int countNodes(TreeNode *root) {
    if (root == NULL) {
      return 0;
    }
    TreeNode *lastNode = root;
    vector<char> paths;
    int h = count_left_levels(root);
    if (h == count_right_levels(root)) {
      return pow(2, h) - 1;
    }
    int remain = 0;
    while (lastNode != NULL) {
      int rightl = count_right_levels(lastNode->left);
      int leftl = count_left_levels(lastNode->left);
      if (lastNode->right == NULL) {
        remain++;
        break;
      }
      if (leftl <= rightl) {
        if (count_left_levels(lastNode->right) >= rightl) {
          lastNode = lastNode->right;
          paths.push_back('R');
        } else {
          lastNode = lastNode->left;
          paths.push_back('L');
        }
      } else {
        lastNode = lastNode->left;
        paths.push_back('L');
      }
    }
    for (int i = 0; i < paths.size(); i++) {
      if (paths[i] == 'R') {
        remain += pow(2, h - 2 - i);
      }
    }
    return pow(2, h - 1) - 1 + remain;
  }
};