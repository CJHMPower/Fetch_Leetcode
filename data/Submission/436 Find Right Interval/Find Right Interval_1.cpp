//-*- coding:utf-8 -*-
// Generated by the Fetch-Leetcode project on the Github
// https://github.com/CJHMPower/Fetch-Leetcode/

// 436 Find Right Interval
// https://leetcode.com//problems/find-right-interval/description/
// Fetched at 2018-07-24
// Submitted 6 months ago
// Runtime: 87 ms
// This solution defeats 14.03% cpp solutions

/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
 public:
  int binary_search(vector<pair<int, int>> &nums, int target) {
    int low = 0, high = nums.size() - 1;
    while (high >= low) {
      int mid = low + (high - low) / 2;
      if (nums[mid].second == target) {
        return nums[mid].first;
      } else if (nums[mid].second < target) {
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }
    if (low < nums.size()) {
      return nums[low].first;
    } else {
      return -1;
    }
  }
  vector<int> findRightInterval(vector<Interval> &intervals) {
    vector<pair<int, int>> start(intervals.size(), {0, 0});
    for (int i = 0; i < intervals.size(); i++) {
      start[i] = {i, intervals[i].start};
    }
    sort(start.begin(), start.end(), [](pair<int, int> &a, pair<int, int> &b) {
      return a.second < b.second;
    });
    vector<int> ret(intervals.size(), 0);
    for (int i = 0; i < intervals.size(); i++) {
      int index = binary_search(start, intervals[i].end);
      ret[i] = index;
    }
    return ret;
  }
};