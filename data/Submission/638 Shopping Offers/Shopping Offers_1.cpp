//-*- coding:utf-8 -*-
// Generated by the Fetch-Leetcode project on the Github
// https://github.com/CJHMPower/Fetch-Leetcode/

// 638 Shopping Offers
// https://leetcode.com//problems/shopping-offers/description/
// Fetched at 2018-07-24
// Submitted 2 months, 3 weeks ago
// Runtime: 9 ms
// This solution defeats 14.16% cpp solutions

class Solution {
 public:
  map<vector<int>, int> dp;

  int DFS(vector<int>& price, vector<vector<int>>& special,
          vector<int>& needs) {
    if (dp.find(needs) != dp.end()) {
      return dp[needs];
    }
    int ret = 0;
    for (int i = 0; i < price.size(); i++) {
      ret += (price[i] * needs[i]);
    }
    for (int i = 0; i < special.size(); i++) {
      bool valid = true;
      vector<int> temp = needs;
      for (int j = 0; j < needs.size(); j++) {
        if (special[i][j] > needs[j]) {
          valid = false;
          break;
        }
        temp[j] -= special[i][j];
      }
      if (valid) {
        if (ret > special[i].back()) {
          int val = DFS(price, special, temp);

          ret = min(ret, val + special[i].back());
        }
      }
    }
    dp[needs] = ret;
    return ret;
  }
  int shoppingOffers(vector<int>& price, vector<vector<int>>& special,
                     vector<int>& needs) {
    dp[vector<int>(needs.size(), 0)] = 0;

    return DFS(price, special, needs);
  }
};