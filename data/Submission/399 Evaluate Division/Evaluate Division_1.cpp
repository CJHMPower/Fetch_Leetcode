//-*- coding:utf-8 -*-
// Generated by the Fetch-Leetcode project on the Github
// https://github.com/CJHMPower/Fetch-Leetcode/

// 399 Evaluate Division
// https://leetcode.com//problems/evaluate-division/description/
// Fetched at 2018-07-24
// Submitted 1 year, 10 months ago
// Runtime: 0 ms
// This solution defeats 100.0% cpp solutions

class Solution {
 public:
  vector<double> calcEquation(vector<pair<string, string>> equations,
                              vector<double>& values,
                              vector<pair<string, string>> queries) {
    map<string, int> node;
    for (int i = 0; i < equations.size(); i++) {
      if (node.find(equations[i].first) == node.end()) {
        node.insert({equations[i].first, node.size()});
      }
      if (node.find(equations[i].second) == node.end()) {
        node.insert({equations[i].second, node.size()});
      }
    }
    int n = node.size();
    vector<vector<double>> graph(n, vector<double>(n, INT_MIN));
    for (int i = 0; i < equations.size(); i++) {
      graph[node[equations[i].first]][node[equations[i].second]] = values[i];
      graph[node[equations[i].second]][node[equations[i].first]] =
          1 / values[i];
    }
    vector<double> result;
    for (auto u : queries) {
      if (node.find(u.first) == node.end() ||
          node.find(u.second) == node.end()) {
        result.push_back(-1.0);
        continue;
      }
      int start = node[u.first];
      int end = node[u.second];
      double decimal = 1;
      stack<int> path;
      path.push(start);
      int i;
      vector<bool> visited(n, false);
      int over = 1;
      visited[start] = true;
      while (path.top() != end) {
        if (over >= n) {
          decimal = -1.0;
          break;
        }
        for (i = 0; i < n; i++) {
          if (visited[i] == false && graph[start][i] > INT_MIN) {
            path.push(i);
            visited[i] = true;
            over++;
            decimal *= graph[start][i];
            start = i;
            break;
          }
        }
        if (i >= n) {
          int v = path.top();
          path.pop();
          if (path.empty()) {
            decimal = -1;
            break;
          }
          start = path.top();
          decimal /= graph[start][v];
        }
      }
      result.push_back(decimal);
    }
    return result;
  }
};