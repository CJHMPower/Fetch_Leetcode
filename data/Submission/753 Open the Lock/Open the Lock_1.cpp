//-*- coding:utf-8 -*-
// Generated by the Fetch-Leetcode project on the Github
// https://github.com/CJHMPower/Fetch-Leetcode/

// 753 Open the Lock
// https://leetcode.com//problems/open-the-lock/description/
// Fetched at 2018-07-24
// Submitted 2 months, 2 weeks ago
// Runtime: 245 ms
// This solution defeats 14.46% cpp solutions

class Solution {
 public:
  set<string> visited;
  set<string> deadends_set;
  vector<string> next(string& state) {
    vector<string> ret;
    for (int i = 0; i < state.size(); i++) {
      string temp = state;
      temp[i] = char('0' + ((state[i] - '0') + 1) % 10);
      if (visited.find(temp) == visited.end() &&
          deadends_set.find(temp) == deadends_set.end()) {
        visited.insert(temp);
        ret.push_back(temp);
      }
      temp[i] = char('0' + ((state[i] - '0') - 1 + 10) % 10);
      if (visited.find(temp) == visited.end() &&
          deadends_set.find(temp) == deadends_set.end()) {
        visited.insert(temp);
        ret.push_back(temp);
      }
    }
    return ret;
  }
  int openLock(vector<string>& deadends, string target) {
    if (target == "0000") {
      return 0;
    }
    visited.insert("0000");
    for (auto s : deadends) {
      if (s == "0000") {
        return -1;
      }
      deadends_set.insert(s);
    }

    queue<string> bfs;
    bfs.push("0000");
    int length = 0;
    string start;
    queue<int> level;
    level.push(0);
    while (!bfs.empty()) {
      start = bfs.front();
      bfs.pop();
      int val = level.front();
      level.pop();
      vector<string> next_step = next(start);

      for (auto s : next_step) {
        if (s == target) {
          return val + 1;
        }
        bfs.push(s);
        level.push(val + 1);
      }
    }
    return -1;
  }
};