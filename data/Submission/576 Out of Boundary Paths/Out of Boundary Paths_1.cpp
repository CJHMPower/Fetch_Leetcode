//-*- coding:utf-8 -*-
// Generated by the Fetch-Leetcode project on the Github
// https://github.com/CJHMPower/Fetch-Leetcode/

// 576 Out of Boundary Paths
// https://leetcode.com//problems/out-of-boundary-paths/description/
// Fetched at 2018-07-24
// Submitted 2 months, 4 weeks ago
// Runtime: 10 ms
// This solution defeats 19.57% cpp solutions

class Solution {
 public:
  int findPaths(int m, int n, int N, int i, int j) {
#define mod int(pow(10, 9) + 7)
    vector<vector<long long int>> dp(m, vector<long long int>(n, 0));
    for (int ii = 0; ii < n; ii++) {
      dp[0][ii] += 1;
      dp[m - 1][ii] += 1;
    }
    for (int jj = 0; jj < m; jj++) {
      dp[jj][0] += 1;
      dp[jj][n - 1] += 1;
    }
    if (N == 0) {
      return !(i >= 0 && j >= 0 && i < m && j < n);
    }
    if (N == 1) {
      return dp[i][j];
    }
    long long int ret = dp[i][j];
    for (int times = 1; times < N; times++) {
      vector<vector<long long int>> temp = dp;
      for (int ii = 0; ii < m; ii++) {
        for (int jj = 0; jj < n; jj++) {
          dp[ii][jj] = 0;

          if (ii - 1 >= 0) {
            dp[ii][jj] = (dp[ii][jj] + temp[ii - 1][jj]) % mod;
          }
          if (jj - 1 >= 0) {
            dp[ii][jj] = (dp[ii][jj] + temp[ii][jj - 1]) % mod;
          }
          if (ii + 1 < m) {
            dp[ii][jj] = (dp[ii][jj] + temp[ii + 1][jj]) % mod;
          }
          if (jj + 1 < n) {
            dp[ii][jj] = (dp[ii][jj] + temp[ii][jj + 1]) % mod;
          }
        }
      }

      ret = (ret + dp[i][j]) % mod;
    }
    return ret;
  }
};