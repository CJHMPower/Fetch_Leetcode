//-*- coding:utf-8 -*-
// Generated by the Fetch-Leetcode project on the Github
// https://github.com/CJHMPower/Fetch-Leetcode/

// 211 Add and Search Word - Data structure design
// https://leetcode.com//problems/add-and-search-word---data-structure-design/description/
// Fetched at 2018-07-24
// Submitted 2 years, 1 month ago
// Runtime: 112 ms
// This solution defeats 4.67% cpp solutions

class WordNode {
 public:
  WordNode() : end(false) {
    for (int i = 0; i < Size; i++) {
      children[i] = nullptr;
    }
  }
  static const int Size = 26;
  bool end;
  WordNode* children[Size];
};
class WordDictionary {
 public:
  WordDictionary() { root = new WordNode(); }
  // Inserts a word into the trie.
  void addWord(string word) {
    WordNode* cur = root;
    int i = 0;
    while (i < word.size() && cur->children[word[i] - 'a'] != nullptr) {
      cur = cur->children[word[i] - 'a'];
      i++;
    }
    if (i >= word.size()) {
      cur->end = true;
      return;
    }
    while (i < word.size()) {
      cur->children[word[i] - 'a'] = new WordNode();
      cur = cur->children[word[i] - 'a'];
      i++;
    }
    cur->end = true;
  }
  bool help_search(string word, WordNode* p) {
    if (p == nullptr) {
      return false;
    }
    WordNode* cur = p;
    int i = 0;
    while (i < word.size() && cur != nullptr) {
      if (word[i] == '.') {
        if (i != word.size() - 1) {
          int j = 0;
          for (j = 0; j < cur->Size; j++) {
            if (help_search(word.substr(i + 1, word.size() - i - 1),
                            cur->children[j])) {
              return true;
            }
          }
          if (j >= cur->Size) {
            return false;
          }
        } else {
          for (int j = 0; j < cur->Size; j++) {
            if (cur->children[j] != nullptr && cur->children[j]->end == true) {
              return true;
            }
          }
          return false;
        }
      } else if (cur->children[word[i] - 'a'] == nullptr) {
        return false;
      }
      cur = cur->children[word[i] - 'a'];
      i++;
    }
    return cur->end;
  }
  // Returns if the word is in the trie.
  bool search(string word) {
    WordNode* cur = root;
    return help_search(word, cur);
  }
  // Returns if there is any word in the trie
  // that starts with the given prefix.
 private:
  WordNode* root;
};

// Your WordDictionary object will be instantiated and called as such:
// WordDictionary wordDictionary;
// wordDictionary.addWord("word");
// wordDictionary.search("pattern");