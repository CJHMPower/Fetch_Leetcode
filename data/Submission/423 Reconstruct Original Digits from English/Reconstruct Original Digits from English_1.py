#-*- coding:utf-8 -*-
#Generated by the Fetch-Leetcode project on the Github
#https://github.com/CJHMPower/Fetch-Leetcode/

#423 Reconstruct Original Digits from English
#https://leetcode.com//problems/reconstruct-original-digits-from-english/description/
#Fetched at 2018-07-24
#Submitted 10 months ago
#Runtime: 142 ms
#This solution defeats 24.42% python solutions


class Solution(object):
    def sub_number(self, count, num, time):
        for c in num:
            count[c] -= time
            if count[c] <= 0:
                count.pop(c)
        return count

    def originalDigits(self, s):
        """
        :type s: str
        :rtype: str
        """
        from copy import copy
        count = {}
        for c in s:
            if c not in count:
                count[c] = 1
            else:
                count[c] += 1
        number = {
            0: 'zero',
            1: 'one',
            2: 'two',
            3: 'three',
            4: 'four',
            5: 'five',
            6: 'six',
            7: 'seven',
            8: 'eight',
            9: 'nine'
        }
        result = []
        if 'z' in count:
            result.extend([0] * count['z'])
            count = self.sub_number(count, number[0], count['z'])
        if 'x' in count:
            result.extend([6] * count['x'])
            count = self.sub_number(count, number[6], count['x'])
        if 'g' in count:
            result.extend([8] * count['g'])
            count = self.sub_number(count, number[8], count['g'])

        if 'w' in count:
            result.extend([2] * count['w'])
            count = self.sub_number(count, number[2], count['w'])

        if 'u' in count:
            result.extend([4] * count['u'])
            count = self.sub_number(count, number[4], count['u'])

        if 's' in count:
            result.extend([7] * count['s'])
            count = self.sub_number(count, number[7], count['s'])

        if 'v' in count:
            result.extend([5] * count['v'])
            count = self.sub_number(count, number[5], count['v'])

        if 't' in count:
            result.extend([3] * count['t'])
            count = self.sub_number(count, number[3], count['t'])

        if 'i' in count:
            result.extend([9] * count['i'])
            count = self.sub_number(count, number[9], count['i'])

        if 'o' in count:
            result.extend([1] * count['o'])
            count = self.sub_number(count, number[1], count['o'])

        result = sorted(result)
        ret = ''
        for i in result:
            ret = ret + str(i)
        return ret
