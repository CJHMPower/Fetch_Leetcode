//-*- coding:utf-8 -*-
// Generated by the Fetch-Leetcode project on the Github
// https://github.com/CJHMPower/Fetch-Leetcode/

// 433 Minimum Genetic Mutation
// https://leetcode.com//problems/minimum-genetic-mutation/description/
// Fetched at 2018-07-24
// Submitted 4 months ago
// Runtime: 3 ms

struct node {
  string s;
  vector<int> list_node;
  node(string &r) : s(r), list_node(vector<int>()){};
};

class Solution {
 public:
  bool cmp(string &a, string &b) {
    bool flag = false;
    if (a.size() != b.size()) {
      return false;
    }
    for (int i = 0; i < a.size(); i++) {
      if (a[i] != b[i]) {
        if (flag == false)
          flag = true;
        else {
          return false;
        }
      }
    }
    return flag;
  }
  int BFS(vector<node> &adject, int start, int end) {
    queue<int> q;
    q.push(start);
    int depth = 0;
    vector<bool> record(adject.size(), false);
    record[0] = true;
    int count = 1;
    while (!q.empty()) {
      int t = q.front();
      q.pop();
      if (--count == 0) {
        depth += 1;
        for (auto a : adject[t].list_node) {
          if (record[a] == false) {
            count++;
          }
        }
      }

      for (int i = 0; i < adject[t].list_node.size(); i++) {
        if (record[adject[t].list_node[i]] == false) {
          if (adject[t].list_node[i] == end) {
            return depth;
          }
          record[adject[t].list_node[i]] = true;
          q.push(adject[t].list_node[i]);
        }
      }
    }
    return -1;
  }
  int minMutation(string start, string end, vector<string> &bank) {
    vector<node> adject;
    adject.push_back(node(start));
    for (int i = 0; i < bank.size(); i++) {
      adject.push_back(node(bank[i]));
    }
    int end_idx = -1;
    for (int i = 0; i < bank.size(); i++) {
      if (bank[i] == end) {
        end_idx = i + 1;
      }
      if (cmp(start, bank[i]) == true) {
        adject[i + 1].list_node.push_back(0);
        adject[0].list_node.push_back(i + 1);
      }
      for (int j = i + 1; j < bank.size(); j++) {
        if (cmp(bank[i], bank[j]) == true) {
          adject[i + 1].list_node.push_back(j + 1);
          adject[j + 1].list_node.push_back(i + 1);
        }
      }
    }
    if (end_idx == -1) {
      return -1;
    }

    return BFS(adject, 0, end_idx);
  }
};