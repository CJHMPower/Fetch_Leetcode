//-*- coding:utf-8 -*-
// Generated by the Fetch-Leetcode project on the Github
// https://github.com/CJHMPower/Fetch-Leetcode/

// 261 Graph Valid Tree
// https://leetcode.com//problems/graph-valid-tree/description/
// Fetched at 2018-07-24
// Submitted 3 months ago
// Runtime: 13 ms
// This solution defeats 7.67% cpp solutions

class Solution {
 public:
  bool dfs(vector<vector<int>>& adjects, vector<int>& visited, int node,
           int parent) {
    if (visited[node] == 0) {
      visited[node] = 1;
    }
    for (auto point : adjects[node]) {
      /* cout << node<<" "<<point << " " << visited[point] << " " << parent <<
       * endl; */
      if (visited[point] == 1 && point != parent) {
        return false;
      } else if (visited[point] == 0) {
        if (dfs(adjects, visited, point, node) == false) {
          return false;
        }
      }
    }
    visited[node] = 2;
    return true;
  }
  bool validTree(int n, vector<pair<int, int>>& edges) {
    vector<vector<int>> adjects(n, vector<int>());
    for (auto edge : edges) {
      adjects[edge.first].push_back(edge.second);
      adjects[edge.second].push_back(edge.first);
    }
    vector<int> visited(n, 0);
    if (dfs(adjects, visited, 0, -1) == false) {
      return false;
    } else {
      for (int i = 0; i < n; i++) {
        if (visited[i] == 0) {
          return false;
        }
      }
    }
    return true;
  }
};